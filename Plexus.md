#### Свертка ####
> Свёртка (англ. convolution) — это операция, показывающая «схожесть» одной функции с отражённой и сдвинутой копией другой.

В случае работы с изображениями — свёртка — это операция вычисления нового значения заданного пикселя, при которой учитываются значения окружающих его соседних пикселей. 
Главным элементом свёртки является т.н. **ядро** свёртки — это матрица (произвольного размера и отношения сторон; чаще всего используется квадратная матрица (по-умолчанию, размеры 3х3)). 
>[0][0][0]  
>[0][я][0]  
>[0][0][0]

У ядра свёртки есть важный параметр — **якорь** — это элемент матрицы (чаще всего — центр), который прикладывается к заданному пикселю изображения.

Работает свёртка очень просто:
При вычислении нового значения выбранного пикселя изображения, ядро свёртки прикладывается своим центром к этому пикселю. Соседние пиксели так же накрываются ядром. 
Далее, вычисляется сумма произведений значений пикселей изображения на значения, накрывшего данный пиксель элемента ядра. 
Полученная сумма и является новым значением выбранного пикселя. 
Теперь, если применить свёртку к каждому пикселю изображения, то получится некий эффект, зависящий от выбранного ядра свертки.
#### Пример ####
Пусть у нас есть клеточное поле, которое соответствует пикселям исходного изображния:
>[47][48][49]  
>[47][50][42]  
>[47][48][42]  

и есть ядро свёртки, представляющее собой матрицу 3х3 с якорем в центре и элементами:
>[0][1][0]  
>[0][0][0]  
>[0][0][0]  

Результат операции наложения нашего ядра на пиксель со значением 50:
>[47][48][49]  
>[47]**[48]**[42]  
>[47][48][42]

Всё очень просто:
> результат = 47*0 + 48*1 + 49*0 + 47*0 + 50*0 + 42*0 + 47*0 + 48*0 + 42*0 = 48

#### Пример кода ####
С OpenCV операция свёртки реализуется функцией **cvFilter2D()**:
```c++
CVAPI(void) cvFilter2D( const CvArr* src, CvArr* dst, const CvMat* kernel,
                        CvPoint anchor CV_DEFAULT(cvPoint(-1,-1)));
```
-свёртка изображения при помощи ядра kernel

**src** — исходное изображение
**dst** — изображение для сохранения результа
**kernel** — ядро свёртки (массив из одного канала из элементов типа float)
**anchor** — якорь ядра ( (-1,-1) говорит, что якорь в центре (для ядра нечётной размерности))
```c++
//
// применяем фильтр к изображению при помощи cvFilter2D()
//

#include <cv.h>
#include <highgui.h>
#include <stdlib.h>
#include <stdio.h>

IplImage* image = 0;
IplImage* dst = 0;

int main(int argc, char* argv[])
{
        // имя картинки задаётся первым параметром
        char* filename = argc == 2 ? argv[1] : "Image0.jpg";
        // получаем картинку
        image = cvLoadImage(filename,1);

        printf("[i] image: %s\n", filename);
        assert( image != 0 );

        // клонируем картинку 
        dst = cvCloneImage(image);

        // окно для отображения картинки
        cvNamedWindow("original",CV_WINDOW_AUTOSIZE);
        cvNamedWindow("cvFilter2D",CV_WINDOW_AUTOSIZE);

        float kernel[9];
        kernel[0]=0;
        kernel[1]=0;
        kernel[2]=0;

        kernel[3]=0;
        kernel[4]=1;
        kernel[5]=0;

        kernel[6]=0;
        kernel[7]=0;
        kernel[8]=0;

        // матрица
        CvMat kernel_matrix=cvMat(3,3,CV_32FC1,kernel);

        // накладываем фильтр
        cvFilter2D(image, dst, &kernel_matrix, cvPoint(-1,-1));

        // показываем картинку
        cvShowImage("original",image);
        cvShowImage("cvFilter2D",dst);

        // ждём нажатия клавиши
        cvWaitKey(0);

        // освобождаем ресурсы
        cvReleaseImage(&image);
        cvReleaseImage(&dst);
        // удаляем окна
        cvDestroyAllWindows();
        return 0;
}
```
При данном ядре никаких изменений в картинке не наблюдается. 
Изменим значение фильтра:
```c++
// увеличение яркости
        kernel[0]=-0.1;
        kernel[1]=0.2;
        kernel[2]=-0.1;

        kernel[3]=0.2;
        kernel[4]=3;
        kernel[5]=0.2;

        kernel[6]=-0.1;
        kernel[7]=0.2;
        kernel[8]=-0.1;
```
Результат работы:

![](http://robocraft.ru/files/opencv/cvFilter2D_03.png)